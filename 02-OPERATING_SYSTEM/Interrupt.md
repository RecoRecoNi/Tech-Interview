# Interrupt(인터럽트)

## Interrupt의 정의

**CPU가 프로그램을 실행하고 있을 때,** 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요할 경우에 **마이크로 오퍼레이션**까지 처리 후 **마이크로 프로세서(CPU)**에게 알려 처리 할 수 있도록 하는 것 입니다.

## 인터럽트는 어떻게 처리하나요?

<p align="center"><img src="./images/interrupt1.png" height="400" width="500px"></p>

1. 현재 진행 중인 작업을 마무리합니다. 실행 중인 명령어 사이클을 완료하고, 다음 명령어를 가져오기 위해 CPU는 잠시 쉬게 됩니다.

2. CPU는 중요한 작업을 수행 중이지만, 하이로 인터럽트 마스크 비트를 확인합니다. 이 비트가 설정되어 있다면, 인터럽트를 무시하고 계속 작업을 진행합니다.

3. 발생한 인터럽트의 종류를 확인합니다. 어떤 사건이 발생했는지를 알아보기 위해 인터럽트 벡터를 참조합니다.

4. 그 다음, 해당 인터럽트에 대응하는 **인터럽트 서비스 루틴 \(ISR, 인터럽트 핸들러\)** 의 주소를 찾습니다.

5. CPU는 인터럽트 서비스 루틴으로 이동합니다. 이 때, 현재 실행 중이던 프로그램의 위치를 잠시 저장합니다.

6. 현재 진행 중인 프로그램의 레지스터 값을 백업합니다. 이렇게 하여, 인터럽트 처리 도중에도 중요한 데이터를 보호할 수 있습니다.

7. 이제 해당 인터럽트에 대응하는 인터럽트 서비스 루틴을 실행합니다. 이 루틴은 인터럽트가 발생한 원인을 처리하고 필요한 작업을 수행합니다.

8. 인터럽트 처리가 완료되면, 백업한 레지스터 값을 복원합니다. 그러면 현재 실행 중이었던 프로그램을 이어서 진행할 수 있습니다.

9. 인터럽트 서비스 루틴의 끝에 도달하면, **IRET 명령어**를 사용하여 인터럽트를 해제하고 원래의 실행 위치로 복귀합니다.

10. IRET 명령어가 실행되면, 백업해 둔 **프로그램 카운터 (PC) 값**을 복원하여 이전에 실행 중이었던 위치로 다시 돌아갑니다.

## Polling 방식에 대해 설명해주세요.

**컴퓨터 시스템에서 외부 이벤트를 감지하고 처리하는 접근방식**

- 폴링 방식은 프로세서가 **주기적으로 혹은 정기적으로** 외부 장치나 상태를 계속 확인하여 어떤 동작을 수행하는 방식입니다.
- 프로세서가 직접 확인하기 때문에 외부 이벤트가 발생하지 않더라도 **지속적으로 시스템 자원을 소비**하게 됩니다.
- 예를 들어, 키보드 입력을 폴링하는 경우, 프로세서가 계속해서 키보드 상태를 확인하여 키 입력을 처리합니다.

**Polling 방식 vs 인터럽트 방식**

- 폴링 : 이벤트를 수행하라는 **신호를 받았는지 안 받았는지를 주기적으로 검사**하면서 그 신호를 받았을 대 이벤트를 실행하는 방식입니다.
  - 구현이 쉽다는 장점과 반응시간이 느리고 리소스를 많이 차지한다는 단점이 존재합니다.
- 인터럽트 : **이벤트를 수행하라는 신호를 받으면** 핸들러를 통해서 바로 이벤트를 수행하는 방식입니다.

  - 인터럽트는 정확한 타이밍, 짧은 반응시간의 장점과 핸들러를 통해야하기 때문에 구현상의 단점이 존재합니다.

## HW/SW 인터럽트에 대해 설명해주세요.

- HW(하드웨어) 인터럽트

  - 하드웨어 인터럽트는 **외부 하드웨어 장치나 상태**에서 발생하는 이벤트로, 주로 시스템의 물리적인 변화나 입력 신호로 인해 발생한다.
  - 예를 들어, **키보드나 마우스의 버튼 클릭**, **타이머** 등의 하드웨어 장치에서 발생하는 이벤트가 하드웨어 인터럽트로 간주된다.

- SW(소프트웨어) 인터럽트

  - 소프트웨어 인터럽트는 프로그램 실행 중에 **명시적으로 소프트웨어적으로 발생시키는 인터럽트**로, 주로 **시스템 서비스를 호출**하거나 **예외 상황을 처리**하는 데 사용됩니다.
  - 시스템 서비스를 호출하는 경우, **응용 프로그램이 운영체제의 기능을 활용**하기 위해 소프트웨어 인터럽트를 발생시킵니다. 이를 통해 **파일 입출력**, **메모리 관리**, **프로세스 관리** 등의 작업을 수행할 수 있습니다.
  - 예외 상황을 처리하는 경우, 소프트웨어 인터럽트를 사용하여 **예외 핸들러를 호출**하여 오류나 예외 상황을 처리한다.
  - 예시로는 ZeroDivisionException, System Call 등이 있습니다.

### 인터럽트와 시스템 콜 처리 예제 : File Read

<p align="center"><img src="./images/interrupt2.png" height="400" width="500px"></p>

- 시스템 서비스를 호출하는 경우, **응용 프로그램이 운영체제의 기능을 활용**하기 위해 소프트웨어 인터럽트를 발생시킵니다. 이를 통해 **파일 입출력**, **메모리 관리**, **프로세스 관리** 등의 작업을 수행할 수 있습니다.

**가정 : Running Thread1(t1) 과 Ready Thread2(t2)가 있고, Single Core에서 동작할 때**

<p align="center"><img src="./images/interrupt3.png" height="400"></p>

- 파일을 읽기 위해서는 시스템 호출인 `read`를 호출합니다.
  - 커널 모드로 진입하게 됩니다.
  - CPU의 현재 상태를 저장합니다.
  - 파일을 읽을 준비를 위해 SSD와 소통합니다.
    - `read` 시스템 호출은 블록 시스템 호출이므로, 파일을 읽을 준비가 완료될 때까지 기다려야 합니다. 따라서 해당 작업을 기다리기 위해 현재 실행 중이던 작업인 t1을 대기 상태로 변경합니다.
  - 이로 인해 CPU는 더 이상 진행 중인 작업이 없기 때문에 준비 상태에 있던 다른 작업인 t2를 실행 상태로 전환합니다.
  - 그 후, 커널 모드에서 유저 모드로 전환하게 됩니다. (현재 CPU 자원 통제 권한은 t2에 있습니다.)
- SSD 측에서는 t1이 파일을 읽을 준비가 되었다는 정보를 인터럽트를 통해 알려줍니다.
  - 인터럽트 처리를 위해 커널 모드로 진입합니다.
  - t2의 CPU 상태를 저장합니다.
  - t1을 준비 상태로 변경합니다.
  - 이전에 t2가 중단되었던 지점부터 다시 시작할 수 있도록 t2의 CPU 상태를 복원합니다.
- (가정: 멀티 쓰레드 환경) t2가 주어진 타이머 시간이 모두 소요되어 인터럽트가 발생합니다.
  - 커널 모드로 진입합니다.
  - t2의 CPU 상태를 저장하고, t2는 준비 상태로 변경됩니다.
  - t1이 실행 상태로 전환되며, 파일 읽기 시스템 호출을 호출했을 때 저장한 t1의 CPU 상태가 복원됩니다.
  - 유저 모드로 전환됩니다.
- 이제 다시 통제권은 t1에게 돌아옵니다. 파일을 읽을 준비가 완료된 t1은 실제 읽어오는 작업을 계속 진행하게 됩니다.

## 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?

- 여러 장치에서 인터럽트가 동시에 발생하거나 인터럽트 서비스 루틴 수행 중 인터럽트가 발생했을 경우 **우선순위**를 따져서 처리합니다.
  - **전원 이상(Power fail)**
  - **기계 착오(Machine Check)**
  - **외부 신호(External) > 입출력(I/O)**
  - **명령어 잘못**
  - **프로그램 검사(Program Check)**
  - **SVC(SuperVisor Call)**
- 일반적으로 하드웨어 인터럽트가 소프트웨어 인터럽트보다 우선 순위가 높고 내부 인터럽트 보다 외부 인터럽트가 우선 순위가 높습니다. **(하드웨어 인터럽트 > 소프트웨어 인터럽트) , (외부 인터럽트 > 내부 인터럽트)**
