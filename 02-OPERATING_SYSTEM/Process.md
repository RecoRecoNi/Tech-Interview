# Process
## 💡 프로세스가 무엇인가요.
<p align="center"><img src="https://github.com/RecoRecoNi/Tech-Interview/assets/70088803/1d037f99-868b-4e7c-90b0-c22e4d4f5498" height="300" width="600px"></p>

<aside>
  
`프로세스`: **PCB를 할당 받은 프로그램**   
- **커널에 등록**되고 커널의 **관리**하에 있는 작업
- **각종 자원들을 요청하고 할당** 받을 수 있는 개체
- **프로세스 관리 블록(PCB)을 할당** 받은 개체
- **능동적인 개체(Active Entity)**
    - 실행 중에 각종 자원을 요구, 할당, 반납하며 진행
  
</aside>

즉, `프로그램`은 저장장치에 저장된 **정적인 상태**이고, `프로세스`는 실행을 위해 메모리에 올라온 **동적인 상태**를 말합니다.

</br>


## 📑 꼬리질문
### 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.
- `작업(Job)` / **`프로그램(Program)`**
    - 실행할 프로그램 + 데이터
    - 컴퓨터 시스템에 실행 요청 전의 상태 (저장장치에 저장된 정적인 상태)
    
- **`프로세스(Process)`**
    - 실행을 위해 시스템(커널)에 등록된 작업
    - 시스템 성능 향상을 위해 커널에 의해 관리 됨
    - CPU 스케줄링의 대상이 되는 작업(task, 실행을 위해 메모리에 올라온 동적인 상태)

- **`쓰레드(Thread)`**    
    - Light Weight Process (LWP)
    - **프로세서** 활용의 기본 단위
    - 제어 요소 외 코드, 데이터 및 자원들은 프로세스 내 다른 스레드들과 공유
    - 전통적 프로세스 = 단일 스레드 프로세스
      
  <p align="center"><img src="https://github.com/RecoRecoNi/Tech-Interview/assets/70088803/7935e06d-bdd3-4560-9902-d27cf1bc2442" height="450" width="700px"></p>
  프로세스 내에서 각 스레드는 제어 요소를 제외한 코드 영역, 전역 데이터, 힙 영역을 공유합니다.
    
**요약**  
→ 프로그램과 프로세스는 PCB를 할당 받았는지에 차이가 있고, 자원 할당 유무를 통해서 확인할 수 있다.    
→ 스레드는 자원을 할당 받은 프로세스가 프로세서를 활용해 자원을 제어하는 기본 단위로 쓰인다.


### PCB가 무엇인가요?
<p align="center"><img src="https://github.com/RecoRecoNi/Tech-Interview/assets/70088803/cc79e320-8bb6-47f9-a458-d2e339a1f2a0" height="450" width="280px"></p>

**`프로세스 제어 블록(Process Control Block)`**

- 프로세스를 실행하는 데 필요한 정보를 보관하는 자료구조입니다.    
- PCB는 메모리의 커널 영역에 생성되며 운영체제가 프로세스 관리에 필요한 정보를 저장합니다.   
- 모든 프로세스는 고유의 PCB를 가지고 프로세스 생성시 만들어져 종료시 폐기 됩니다.   

    - `포인터`: 프로세스 제어 블록을 연결해 준비 상태나 대기 상태의 큐를 구현할 때 사용
    - `프로세스 상태` : 생성, 준비, 실행, 대기, 보류 준비, 보류 대기 등으로 프로세스가 현재 어떤 상태에 있는지를 나타냅니다.
    - `프로세스 구분자`: 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자를 저장
    - `프로그램 카운터`: 다음에 실행될 명령어의 위치를 가리키는 프로그램 카운터의 값을 저장
    - `프로세스 우선순위`: 프로세스의 우선순위(중요도)로 CPU 스케줄러가 준비 상태에 있는 프로세스 중 실행 상태로 옮겨야 할 프로세스를 선택할 때 이 프로세스 우선순위를 기준으로 삼습니다.
    - `각종 레지스터 정보`: 다음에 실행할 때 사용하기 위해 이전에 실행할 때 사용한 레지스터의 중간값을 보관합니다.
    - `메모리 관리 정보` : 프로세스의 메모리 위치 정보, 메모리 보호를 위한 경계 레지스터 값과 한계 레지스터 값 등이 저장됩니다.
    - `할당된 자원 정보`: 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보
    - `계정 정보` : 계정 번호, CPU 할당 시간, CPU 사용 시간 등에 대한 정보
    - `부모 프로세스 구분자와 자식 프로세스 구분자` : PPID(Parent PID), CPID(Child PID)

</br>

### 그렇다면, 스레드는 PCB를 갖고 있을까요?
- 스레드는 프로세스가 아니기 때문에 PCB를 갖지 않습니다.
- 대신, 스레드는  **`TCB (Thread Control Block)`** 라는 스레드를 관리하는 자료구조를 가지고 있습니다.

<p align="center"><img src="https://github.com/RecoRecoNi/Tech-Interview/assets/70088803/7eecbdd8-feb5-4ccb-b92e-5fc12294aa47" height="400" width="600px"></p>

`PCB`가 주로 프로세스 수준의 정보를 관리하는 데 사용된다면, `TCB`는 스레드 수준의 정보를 관리하는 데 사용됩니다. 

- 스레드의 상태, 레지스터 값, 스레드 고유 식별자, 스레드의 스케줄링 정보 등을 포함합니다.
- 여러 스레드가 하나의 프로세스 내에서 실행될 때, 각 스레드마다 하나의 TCB가 생성되며, 스레드의 독립적인 관리와 스케줄링을 위한 정보를 담고 있습니다.

</br>

### 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?
- 리눅스는 멀티 쓰레드 친화적입니다. 프로그램 내 수 많은 테스크들을 프로세스 안의 하나의 쓰레드가 전부 처리하기엔 부하가 커질 수 있기 때문에 다른 쓰레드를 따로 만들어 필요한 일만 하게끔 합니다.
- 프로세스가 쓰레드를 만드는 과정은, **프로세스가 자식 프로세스를 만드는 과정과 시스템 내에선 크게 다르지 않습**니다. 그래서 **쓰레드를 Light-Weight-Process**라고도 부릅니다.
     
**`프로세스`**
<p align="center"><img src="https://github.com/RecoRecoNi/Tech-Interview/assets/70088803/53b9b373-588d-44a2-a278-c1bf6e5dacd0" height="400" width="600px"></p>

- 리눅스는 부팅할 때 커널을 작동시킵니다. 그리고 해당 커널은 Init 프로세스를 실행합니다. 이때에 Init Process는 모든 프로세스의 부모 프로세스 역할을 수행합니다.   
    - `fork()`를 통해 자식 프로세스 생성
        - 자기 자신 프로세스의 복사본을 만드는 시스템 호출
        - 자식 프로세스는 부모 프로세스의 복사본이기 때문에 부모 프로세스의 자원들, 이를테면 메모리의 내용, 열린 파일의 목록 등이 자식 프로세스에 상속된다.   
    - `exec()`를 통해 다른 작업으로 변경
        - 자식 프로세스는 `exec()` 시스템 호출을 통해 새로운 프로그램으로 전환된다. exec는 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출이다.
           
    
**스레드**
- `pthread_create()`를 통해 프로세스 생성

</br>

### 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?   

- `좀비 프로세스` : **자식 프로세스가 상태를 알리지 않고 죽거나, 먼저 죽는 경우**
    - 이 경우 `좀비 프로세스`가 발생할 수 있습니다. 좀비 프로세스는 전반적인 성능 저하를 일으킵니다.
    - 자식 프로세스가 죽는 경우, 부모 프로세스가 자식 프로세스의 종료 상태 회수할 수 있도록 커널이 자식 프로세스의 최소한의 정보를 남겨둡니다.
    - 이 때, 부모 프로세스는 `wait` 함수를 호출하여 이 상태를 회수할 수 있습니다. `wait` 함수는 자식 프로세스의 종료 상태를 확인하고 해당 상태를 처리합니다.
- `고아 프로세스` : **부모 프로세스가 먼저 죽는 경우**
    - 이 경우 `고아 프로세스`가 발생할 수 있습니다. 운영체제는 이러한 고아 프로세스를 허용하지 않습니다.
    - 부모 프로세스가 먼저 종료되면 자식 프로세스의 새로운 부모 프로세스로 `init(PID=1)`이 설정됩니다.
    - init 프로세스는 자식 프로세스가 종료될 때까지 기다린 후 wait 함수를 호출하여 고아 프로세스의 종료 상태를 회수하는 방법으로 고아 프로세스를 방지합니다.

</br>

### 리눅스에서, 데몬프로세스에 대해 설명해 주세요.

`데몬 프로세스`란 운영체제에서 부팅시 자동으로 켜져 **백그라운드에서 계속 실행되는 프로세스**를 의미합니다.

- 항상 수행되고 있는 프로세스
- 사용자가 직접 제어하지 않고 백그라운드에서 수행
- ex) inetd, syslogd, crond, httpd 등
    - 주로 서비스 제공, 특정 작업의 스케줄링, 네트워크 서비스 관리, 파일 시스템 관리 등과 같은 백그라운드 작업을 수행합니다.

</br>

## 📚 Reference
[블로그 - 좀비 프로세스와 고아 프로세스](https://dongwooklee96.github.io/post/2021/04/03/%EC%A2%80%EB%B9%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EA%B3%A0%EC%95%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/)

[티스토리 - 완전히 정복하는 프로세스 vs 스레드 개념](https://inpa.tistory.com/entry/👩‍💻-프로세스-⚔️-쓰레드-차이#프로세스의_한계)

[도서 - 쉽게 배우는 운영체제]

[도서 - 혼자 공부하는 컴퓨터구조 + 운영체제]

[유튜브 - [OS] Lecture 3. Process Management (1/2) / 운영체제 강의](https://youtu.be/jZuTw2tRT7w?si=0w2HlolX5aI0SYGO)

[유튜브 - [OS] Lecture 4. Tread management / 운영체제 강의](https://www.youtube.com/watch?v=YlnvCIZQDkw)

[티스토리 - [Chapter 4. 스레드]  스레드, PCB와 TCB, 다중 스레드 모델](https://eunajung01.tistory.com/55)

[티스토리 - [운영체제] 좀비 프로세스, 고아 프로세스](https://latter2005.tistory.com/106)

[티스토리 - Context Switching에서의 Thread와 Process의 관계 + PCB, TCB](https://teraphonia.tistory.com/802)

[티스토리 - Systemd란?](https://etloveguitar.tistory.com/57)

[티스토리 - 좀비 프로세스와 고아 프로세스(Zombie process and Orphan process)](https://codetravel.tistory.com/31)

[벨로그 - 리눅스 - 데몬Daemon](https://velog.io/@qlgks1/리눅스-데몬Daemon)