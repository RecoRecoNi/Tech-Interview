# Cookie & Session
## 💡 쿠키와 세션의 차이에 대해 설명해 주세요.

<p align="center"><img src="https://github.com/RecoRecoNi/Tech-Interview/assets/70088803/c11c30a5-69ff-4571-8e24-c97cc699d101" height="400" width="700"></p>


- 쿠키와 세션은 `비슷한 역할을 하며, 동작원리도 비슷`합니다. 그 이유는 `세션도 결국 쿠키를 사용`하기 때문입니다.
- 가장 큰 차이점은 `사용자의 정보가 저장되는 위치`입니다. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다. (**쿠키 : 클라이언트** / **세션 : 서버**)
- **`보안`**: 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만, 세션은 쿠키를 이용해서 sessionid 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋습니다. (**세션 > 쿠키**)
- **`라이프 사이클`**: 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있습니다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있습니다. 반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제됩니다. 예를 들어, 크롬에서 다른 탭을 사용해도 세션은 공유됩니다. 다른 브라우저를 사용하게 되면 다른 세션을 사용 할 수 있습니다.
- **`속도`**: 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 가집니다. (**쿠키 > 세션**)

<details>
  <summary><h3>예시) 쿠키 동작 방식</h3></summary>
  <p align="center">
    <img src="https://github.com/RecoRecoNi/Tech-Interview/assets/70088803/fe882178-836a-44db-abd9-479739832a99" align="center" style="margin-right: 50;" width="45%">
    <img src="https://github.com/RecoRecoNi/Tech-Interview/assets/70088803/3f496428-9040-4e60-95e1-b6862399b55a" align="center" width="45%">
  </p>
    
  1. 클라이언트(웹 브라우저)가 서버에 페이지를 요청
  2. 서버는 클라이언트의 요청을 받고 **클라이언트의 정보를 담은 쿠키를 생성** 후 HTTP set-cookie 옵션을 통해 **헤더에 쿠키를 포함**시켜 응답
  3. 클라이언트는 해당 쿠키를 **쿠키 저장소에 저장**(브라우저가 종료되어도 쿠키 만료 기간이 있다면 **클라이언트에서 보관**하고 있음)
  4. 이후, **같은 요청**을 할 경우 쿠키 저장소에 저장된 쿠키를 **조회**한 후 해당 해당 쿠키를 **HTTP 헤더에 함께 보냄**
  5. **서버**에서 쿠키를 읽어 이전 상태 정보를 변경할 필요가 있을 때 쿠키를 업데이트하여 변경된 쿠키를 **HTTP 헤더에 포함**시켜 응답


</details>

<details>
  <summary><h3>예시) 세션 동작 방식</h3></summary>
  <p align="center">
    <img src="https://github.com/RecoRecoNi/Tech-Interview/assets/70088803/b9b2668a-19e3-484a-ace9-ecccac313ef8" align="center" style="margin-right: 50;" width="45%">
    <img src="https://github.com/RecoRecoNi/Tech-Interview/assets/70088803/57a6be12-924b-4760-890c-6473aa1b26dc" align="center" width="45%">
  </p>

  1. 클라이언트(웹 브라우저)가 서버에 페이지를 요청
  2. 서버는 클라이언트의 요청을 받고 클라이언트의 정보를 담은 **세션을 생성**
  3. 이후 **세션 ID를 담은 쿠키를 생성**하고, HTTP 헤더에 set-cookie 옵션을 통해 **쿠키를 포함시켜 응답**
  4. 클라이언트는 해당 쿠키를 **쿠키 저장소에 저장**
  5. 이후, 클라이언트가 다시 서버에 페이지를 요청할 때 쿠키 저장소에서 저장된 쿠키를 꺼내 **HTTP 요청에 쿠키를 담아 전송**
  6. 서버는 **HTTP 요청의 쿠키**를 읽어 쿠키 안의 **세션 ID를 이용해 클라이언트를 식별** 후 응답

</details>
<br>

## 📑 꼬리질문
### 세션 방식의 로그인 과정에 대해 설명해 주세요.
<p align="center"><img src="https://github.com/RecoRecoNi/Tech-Interview/assets/70088803/c8aff0ef-c796-4d8f-b408-6789ab4f8ed4" height="400" width="700"></p>

`세션기반 인가`는 사용자의 인증 정보가 서버의 세션 저장소에 저장되는 방식

1. 클라이언트는 **유저 정보를 서버에 전송**하고 서버에서는 유저를 검증하여 **정상적인 유저인지 식별**합니다.
2. 문제가 없다면 서버는 클라이언트에게 **세션 ID를 반환**해주고 서버에는 **해당 세션 ID에 해당 유저 정보를 저장**합니다.
3. 이후 클라이언트는 해당 **세션 ID로 요청**을 하게 되고 서버에서는 세션 ID에 저장된 유저 정보를 통해서 클라이언트를 인증하게 됩니다.

<br>

### HTTP의 특성인 Stateless에 대해 설명해 주세요.

- HTTP 프로토콜은 요청과 응답을 교환하는 동안 상태(Status)를 저장하지 않습니다. 따라서 HTTP 레벨에서는 이전에 보냈던 request나 response를 기억하지 못합니다.
- 즉, HTTP 요청은 직전의 요청과 전혀 관련이 없고, 이를 HTTP의 `비상태성(Stateless)`이라고 합니다.

<br>

### Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?

`Stateless`가 무상태를 의미하기 때문에 상태를 유지하는 세션 방식은 이에 반합니다. 하지만 그렇다고 인증을 매번 하는 것 또한 사용자 입장에서 굉장히 불편할 수 있습니다.

그래서 대부분의 웹/앱 서비스에서는 클라이언트의 상태 정보를 유지하는 방향으로 편의성을 제공하고 있고, 이는 보안적인 측면에서 이점이 있습니다. 

이를 위해서 Stateless 특성에 반할 수는 있지만 서버측에 클라이언트 상태 정보를 저장하는 세션 방식을 활용하고 있다고 이해하고 있습니다. 

또한, 무상태를 지향하기 위해 매 요청마다 필요한 정보를 모두 담아 서버와 I/O하는 경우 통신에서 오는 부하와 코스트가 더 클 수 있기에 세션 방식을 사용한다고 생각합니다.

<br>

### 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
### 1) **Sticky Session**
<p align="center"><img src="https://github.com/RecoRecoNi/Tech-Interview/assets/70088803/5e420a74-454e-4a0d-9da2-79d68b06948b" height="400" width="700"></p>

- `Sticky Session`은 첫 요청에 대한 응답을 준 서버에게 끈적끈적하게 붙어서 이후의 모든 요청들을 해당 서버로만 보내는 방법입니다.
- 쿠키나 클라이언트의 IP tracking을 활용하여 기능을 제공합니다.
- 단점은 로드 밸런싱의 효율이 떨어질 수 있습니다. 로드 밸런싱은 트래픽을 여러 대의 서버로 적절하게 분산시켜줘야 하는데 Sticky Session은 특정 서버에게 트래픽을 보내기 때문입니다. 따라서 최악의 경우에는 여러 대의 서버를 둬도 하나의 서버만 사용되는 상황이 발생하게 됩니다.
- 또한, 세션은 하나의 서버에서만 관리되기 때문에 서버가 죽어버리면 서버의 세션 저장소에 있는 모든 세션들이 사라지게 됩니다.
- 이러한 단점은 여러 대의 서버가 세션을 공유한다면 해결할 수 있습니다. 바로 Session Clustering과 Session Server입니다.

### 2) **Session Clustering**
<p align="center"><img src="https://github.com/RecoRecoNi/Tech-Interview/assets/70088803/96563652-dc22-4000-b4d8-dc8eb90e66a5" height="400" width="700"></p>

- 클러스터링이란 여러 대의 서버를 하나의 서버처럼 운영하는 것을 의미합니다. 즉, `Session Clustering`이란 각 서버의 세션 저장소를 하나로 묶어서 관리하는 것입니다.
- 모든 서버가 동일한 세션을 공유하기 때문에 특정 서버로만 트래픽이 몰릴 필요가 없으며, 하나의 서버가 죽어도 세션 정보를 잃어버릴 일은 없게 됩니다.
- 하지만 모든 서버의 세션 데이터를 동일하게 유지하기 위해서 **하나의 세션이 생기면 모든 서버의 세션 저장소를 업데이트**해줘야 하며 그만큼 많은 메모리가 필요하기 때문에 성능 저하가 발생하게 됩니다.
    - 또한, 새로운 서버를 만들 때마다 기존의 세션 데이터를 옮겨서 클러스터링 해줘야 하는 번거로움도 존재합니다.
- 이러한 번거로움을 없애기 위해 세션만 관리하는 별도의 서버를 하나 두는 방식이 바로 Session Server 방식입니다.

### 3) **Session Server**
<p align="center"><img src="https://github.com/RecoRecoNi/Tech-Interview/assets/70088803/08ab89b6-4728-4053-a952-e4f1e3e28c5f" height="400" width="700"></p>

- 서버마다 세션 저장소를 둬서 관리하지 말고 세션만 관리하는 별도의 서버를 하나 두는 방식입니다.
- 세션 서버를 사용하기 때문에 모든 서버의 세션 저장소를 업데이트해줄 필요가 없으며, 클러스터링할 필요도 없습니다.
- 또한, Redis 같은 `In-memory(인메모리)` 데이터 저장소를 사용함으로써 **빠르게 세션을 조회**할 수 있습니다.
- Session Server 방식은 Session Clustering의 단점을 해결하지만, 결국 하나의 Session Server를 통해 관리하기 때문에 서버가 죽어버리면 모든 세션 데이터를 잃게 됩니다.
- 하지만 Redis 같은 In-memory(인메모리) 데이터 저장소는 메모리에 데이터를 저장하면서 다른 서버의 메모리에 실시간으로 복사본을 저장하거나, 디스크에 직접 저장하여 데이터를 보관 및 백업이 가능합니다.
- 또한, Master - Slave 형식으로 구성이 가능하기 때문에 Master Server가 죽어도 Slave Server로 접속하면 서비스를 계속 유지할 수 있는 장점이 있습다.
- 다만, 데이터를 별도로 저장하기 위한 메모리가 추가적으로 필요하고, 메모리 파편화가 발생하는 단점도 있습니다.

<br>

## 🐍 꼬꼬무
### 세션을 사용하면 좋은데 왜 쿠키를 사용할까?

세션은 서버의 자원을 사용하기 때문에 무분별하게 만들다보면 서버의 메모리가 감당할 수 없어질 수가 있고 속도가 느려질 수 있기 때문에 쿠키가 유리할 수 있습니다.

<br>

### 토큰 기반의 로그인 과정에 대해 설명해주세요.

<p align="center"><img src="https://github.com/RecoRecoNi/Tech-Interview/assets/70088803/3561bfb8-529c-49eb-9a2e-dc17362935b7" height="400" width="700"></p>

세션 기반 인증이 인증 정보를 서버에 저장하는 방식이라면, `토큰 기반 인증`은 인증 정보를 클라이언트가 직접 들고 있는 방식입니다. 

이때 인증 정보가 토큰의 형태로 브라우저의 로컬 스토리지(혹은 쿠키)에 저장된다. 토큰의 종류에 따라 다르겠지만, 대표적인 토큰인 JWT의 경우 디지털 서명이 존재해 토큰의 내용이 위변조 되었는지 서버측에서 확인할 수 있습니다.


토큰 기반 인증에서는 사용자가 가지고 있는 토큰을 HTTP 의 Authorization 헤더에 실어 보냅니다. 이 헤더를 수신한 서버는 토큰이 위변조 되었거나, 만료 시각이 지나지 않은지 확인한 이후 토큰에 담겨있는 사용자 인증 정보를 확인해 사용자를 인가합니다.

<br>

### HTTP의 특성인 connectionless에 대해서 설명해주세요.

클라이언트가 요청을 한 후 응답을 받게 되면 그 연결을 끊어버리는 특징입니다.

<br>

### 서버(세션) 기반 인증 시스템 Vs 토큰 기반 인증 시스템

**`서버(세션) 기반 인증 시스템`**

서버의 세션을 사용해 사용자 인증을 하는 방법으로 서버측(서버 램 or 데이터베이스)에서 사용자의 인증정보를 관리하는 것을 의미합니다.   

그러다 보니, 클라이언트로부터 요청을 받으면 클라이언트의 상태를 계속에서 유지해놓고 사용합니다.(Stateful)  

이는 사용자가 증가함에 따라 성능의 문제를 일으킬 수 있으며 확장성이 어렵다는 단점을 지닌다.

</br>

**`토큰 기반 인증 시스템`**

이러한 단점을 극복하기 위한 것이 "토큰 기반 인증 시스템"입니다.  

토큰 기반 인증 시스템은 인증받은 사용자에게 토큰을 발급하고, 로그인이 필요한 작업일 경우 헤더에 토큰을 함께 보내 인증받은 사용자인지 확인합니다.  

이는 서버 기반 인증 시스템과 달리 상태를 유지하지 않으므로 Stateless한 특징을 가지고 있습니다.  

</br>

## 📚 Reference

[유튜브 - 세션 vs 토큰 vs 쿠키? 기초개념 잡아드림. 10분 순삭!](https://www.youtube.com/watch?v=tosLBcAX1vk)

[유튜브 - [10분 테코톡] 디투의 쿠키와 세션](https://www.youtube.com/watch?v=XgcCkcKGbys)

[티스토리 - 쿠키와 세션 개념](https://interconnection.tistory.com/74)

[티스토리 - 아주 쉽게 이해하는 Stateful / Stateless 차이](https://inpa.tistory.com/entry/WEB-📚-Stateful-Stateless-정리)

[블로그 - 세션 기반 인증과 토큰 기반 인증 (feat. 인증과 인가)](https://hudi.blog/session-based-auth-vs-token-based-auth/)

[팔만코딩경 - 토큰과 세션, Stateful과 Stateless](https://80000coding.oopy.io/9a56cae9-8626-4025-b3f9-c02251980d0f)

[티스토리 - 여러 대의 서버가 세션(Session)을 공유하는 방법](https://sorjfkrh5078.tistory.com/287)

[티스토리 - [CS/보안 기초] (1) 쿠키(cookie)와 세션(session)의 차이](https://hec-ker.tistory.com/368)

[티스토리 - JWT 토큰 인증 이란? (쿠키 vs 세션 vs 토큰)](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)
